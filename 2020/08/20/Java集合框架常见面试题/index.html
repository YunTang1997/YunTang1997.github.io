<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yuntang1997.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"livere","storage":true,"lazyload":false,"nav":null,"activeClass":"livere"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1. 剖析面试最常见问题之 Java 集合框架 1.1. 集合概述 1.1.1. Java 集合概览 1.1.2. 说说 List,Set,Map 三者的区别？ 1.1.3. 集合框架底层数据结构总结 1.1.3.1. List 1.1.3.2. Set 1.1.3.3. Map   1.1.4. 如何选用集合? 1.1.5. 为什么要使用集合？ 1.1.6. Iterator 迭代器 1.">
<meta property="og:type" content="article">
<meta property="og:title" content="剖析面试最常见问题之Java集合框架">
<meta property="og:url" content="https://yuntang1997.github.io/2020/08/20/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="YunTang1997の博客">
<meta property="og:description" content="1. 剖析面试最常见问题之 Java 集合框架 1.1. 集合概述 1.1.1. Java 集合概览 1.1.2. 说说 List,Set,Map 三者的区别？ 1.1.3. 集合框架底层数据结构总结 1.1.3.1. List 1.1.3.2. Set 1.1.3.3. Map   1.1.4. 如何选用集合? 1.1.5. 为什么要使用集合？ 1.1.6. Iterator 迭代器 1.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yuntang1997.github.io/2020/08/20/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/images/Java-Collections.jpeg">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png">
<meta property="og:image" content="https://yuntang1997.github.io/2020/08/20/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/images/TreeMap%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="https://yuntang1997.github.io/2020/08/20/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/images/jdk1.8%E4%B9%8B%E5%89%8D%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84-HashMap.png">
<meta property="og:image" content="https://yuntang1997.github.io/2020/08/20/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/images/jdk1.8%E4%B9%8B%E5%90%8E%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84-HashMap.png">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/HashTable%E5%85%A8%E8%A1%A8%E9%94%81.png">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/ConcurrentHashMap%E5%88%86%E6%AE%B5%E9%94%81.jpg">
<meta property="og:image" content="https://yuntang1997.github.io/2020/08/20/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/images/java8_concurrenthashmap.png">
<meta property="og:image" content="https://yuntang1997.github.io/2020/08/20/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/images/ad28e3ba-e419-4724-869c-73879e604da1.png">
<meta property="og:image" content="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B-Arrays.asList()%E6%96%B9%E6%B3%95.png">
<meta property="article:published_time" content="2020-08-20T14:59:00.000Z">
<meta property="article:modified_time" content="2020-08-20T14:59:00.000Z">
<meta property="article:author" content="YunTang1997">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yuntang1997.github.io/2020/08/20/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/images/Java-Collections.jpeg">

<link rel="canonical" href="https://yuntang1997.github.io/2020/08/20/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>剖析面试最常见问题之Java集合框架 | YunTang1997の博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="YunTang1997の博客" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">YunTang1997の博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">学无止尽，慢慢进步</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">8</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">8</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">50</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/YunTang1997" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://yuntang1997.github.io/2020/08/20/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="YunTang1997">
      <meta itemprop="description" content="不要因为一时的安逸蒙蔽了双眼，出来混迟早要还的">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YunTang1997の博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          剖析面试最常见问题之Java集合框架
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-20 22:59:00" itemprop="dateCreated datePublished" datetime="2020-08-20T22:59:00+08:00">2020-08-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

          <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>次
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>22k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>20 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <!-- TOC -->

<ul>
<li><a href="#1-剖析面试最常见问题之-java-集合框架">1. 剖析面试最常见问题之 Java 集合框架</a><ul>
<li><a href="#11-集合概述">1.1. 集合概述</a><ul>
<li><a href="#111-java-集合概览">1.1.1. Java 集合概览</a></li>
<li><a href="#112-说说-listsetmap-三者的区别">1.1.2. 说说 List,Set,Map 三者的区别？</a></li>
<li><a href="#113-集合框架底层数据结构总结">1.1.3. 集合框架底层数据结构总结</a><ul>
<li><a href="#1131-list">1.1.3.1. List</a></li>
<li><a href="#1132-set">1.1.3.2. Set</a></li>
<li><a href="#1133-map">1.1.3.3. Map</a></li>
</ul>
</li>
<li><a href="#114-如何选用集合">1.1.4. 如何选用集合?</a></li>
<li><a href="#115-为什么要使用集合">1.1.5. 为什么要使用集合？</a></li>
<li><a href="#116-iterator-迭代器">1.1.6. Iterator 迭代器</a><ul>
<li><a href="#1161-迭代器-iterator-是什么">1.1.6.1. 迭代器 Iterator 是什么？</a></li>
<li><a href="#1162-迭代器-iterator-有啥用">1.1.6.2. 迭代器 Iterator 有啥用？</a></li>
<li><a href="#1163-如何使用">1.1.6.3. 如何使用？</a></li>
</ul>
</li>
<li><a href="#117-有哪些集合是线程不安全的怎么解决呢">1.1.7. 有哪些集合是线程不安全的？怎么解决呢？</a></li>
</ul>
</li>
<li><a href="#12-collection-子接口之-list">1.2. Collection 子接口之 List</a><ul>
<li><a href="#121-arraylist-和-vector-的区别">1.2.1. Arraylist 和 Vector 的区别?</a></li>
<li><a href="#122-arraylist-与-linkedlist-区别">1.2.2. Arraylist 与 LinkedList 区别?</a><ul>
<li><a href="#1221-补充内容双向链表和双向循环链表">1.2.2.1. 补充内容:双向链表和双向循环链表</a></li>
<li><a href="#1222-补充内容randomaccess-接口">1.2.2.2. 补充内容:RandomAccess 接口</a></li>
</ul>
</li>
<li><a href="#123-说一说-arraylist-的扩容机制吧">1.2.3. 说一说 ArrayList 的扩容机制吧</a></li>
</ul>
</li>
<li><a href="#13-collection-子接口之-set">1.3. Collection 子接口之 Set</a><ul>
<li><a href="#131-comparable-和-comparator-的区别">1.3.1. comparable 和 Comparator 的区别</a><ul>
<li><a href="#1311-comparator-定制排序">1.3.1.1. Comparator 定制排序</a></li>
<li><a href="#1312-重写-compareto-方法实现按年龄来排序">1.3.1.2. 重写 compareTo 方法实现按年龄来排序</a></li>
</ul>
</li>
<li><a href="#132-无序性和不可重复性的含义是什么">1.3.2. 无序性和不可重复性的含义是什么</a></li>
<li><a href="#133-比较-hashsetlinkedhashset-和-treeset-三者的异同">1.3.3. 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</a></li>
</ul>
</li>
<li><a href="#14-map-接口">1.4. Map 接口</a><ul>
<li><a href="#141-hashmap-和-hashtable-的区别">1.4.1. HashMap 和 Hashtable 的区别</a></li>
<li><a href="#142-hashmap-和-hashset-区别">1.4.2. HashMap 和 HashSet 区别</a></li>
<li><a href="#143-hashmap-和-treemap-区别">1.4.3. HashMap 和 TreeMap 区别</a></li>
<li><a href="#144-hashset-如何检查重复">1.4.4. HashSet 如何检查重复</a></li>
<li><a href="#145-hashmap-的底层实现">1.4.5. HashMap 的底层实现</a><ul>
<li><a href="#1451-jdk18-之前">1.4.5.1. JDK1.8 之前</a></li>
<li><a href="#1452-jdk18-之后">1.4.5.2. JDK1.8 之后</a></li>
</ul>
</li>
<li><a href="#146-hashmap-的长度为什么是-2-的幂次方">1.4.6. HashMap 的长度为什么是 2 的幂次方</a></li>
<li><a href="#147-hashmap-多线程操作导致死循环问题">1.4.7. HashMap 多线程操作导致死循环问题</a></li>
<li><a href="#148-hashmap-有哪几种常见的遍历方式">1.4.8. HashMap 有哪几种常见的遍历方式?</a></li>
<li><a href="#149-concurrenthashmap-和-hashtable-的区别">1.4.9. ConcurrentHashMap 和 Hashtable 的区别</a></li>
<li><a href="#1410-concurrenthashmap-线程安全的具体实现方式底层具体实现">1.4.10. ConcurrentHashMap 线程安全的具体实现方式/底层具体实现</a><ul>
<li><a href="#14101-jdk17上面有示意图">1.4.10.1. JDK1.7（上面有示意图）</a></li>
<li><a href="#14102-jdk18-上面有示意图">1.4.10.2. JDK1.8 （上面有示意图）</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#15-collections-工具类">1.5. Collections 工具类</a><ul>
<li><a href="#151-排序操作">1.5.1. 排序操作</a></li>
<li><a href="#152-查找替换操作">1.5.2. 查找,替换操作</a></li>
<li><a href="#153-同步控制">1.5.3. 同步控制</a></li>
</ul>
</li>
<li><a href="#16-其他重要问题">1.6. 其他重要问题</a><ul>
<li><a href="#161-什么是快速失败fail-fast">1.6.1. 什么是快速失败(fail-fast)？</a></li>
<li><a href="#162-什么是安全失败fail-safe呢">1.6.2. 什么是安全失败(fail-safe)呢？</a></li>
<li><a href="#163-arraysaslist避坑指南">1.6.3. Arrays.asList()避坑指南</a><ul>
<li><a href="#1631-简介">1.6.3.1. 简介</a></li>
<li><a href="#1632-阿里巴巴-java-开发手册对其的描述">1.6.3.2. 《阿里巴巴 Java 开发手册》对其的描述</a></li>
<li><a href="#1633-使用时的注意事项总结">1.6.3.3. 使用时的注意事项总结</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- /TOC -->
<a id="more"></a>


<h1 id="1-剖析面试最常见问题之-Java-集合框架"><a href="#1-剖析面试最常见问题之-Java-集合框架" class="headerlink" title="1. 剖析面试最常见问题之 Java 集合框架"></a>1. 剖析面试最常见问题之 Java 集合框架</h1><h2 id="1-1-集合概述"><a href="#1-1-集合概述" class="headerlink" title="1.1. 集合概述"></a>1.1. 集合概述</h2><h3 id="1-1-1-Java-集合概览"><a href="#1-1-1-Java-集合概览" class="headerlink" title="1.1.1. Java 集合概览"></a>1.1.1. Java 集合概览</h3><p>从下图可以看出，在 Java 中除了以 <code>Map</code> 结尾的类之外， 其他类都实现了 <code>Collection</code> 接口。</p>
<p>并且，以 <code>Map</code> 结尾的类都实现了 <code>Map</code> 接口。</p>
<p><img src="images/Java-Collections.jpeg" alt></p>
<h3 id="1-1-2-说说-List-Set-Map-三者的区别？"><a href="#1-1-2-说说-List-Set-Map-三者的区别？" class="headerlink" title="1.1.2. 说说 List,Set,Map 三者的区别？"></a>1.1.2. 说说 List,Set,Map 三者的区别？</h3><ul>
<li><code>List</code>(对付顺序的好帮手)： 存储的元素是有序的、可重复的。</li>
<li><code>Set</code>(注重独一无二的性质): 存储的元素是无序的、不可重复的。</li>
<li><code>Map</code>(用 Key 来搜索的专家): 使用键值对（kye-value）存储，类似于数学上的函数 y=f(x)，“x”代表 key，”y”代表 value，Key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</li>
</ul>
<h3 id="1-1-3-集合框架底层数据结构总结"><a href="#1-1-3-集合框架底层数据结构总结" class="headerlink" title="1.1.3. 集合框架底层数据结构总结"></a>1.1.3. 集合框架底层数据结构总结</h3><p>先来看一下 <code>Collection</code> 接口下面的集合。</p>
<h4 id="1-1-3-1-List"><a href="#1-1-3-1-List" class="headerlink" title="1.1.3.1. List"></a>1.1.3.1. List</h4><ul>
<li><code>Arraylist</code>： <code>Object[]</code>数组</li>
<li><code>Vector</code>：<code>Object[]</code>数组</li>
<li><code>LinkedList</code>： 双向链表(JDK1.6 之前为循环链表，JDK1.7 取消了循环)</li>
</ul>
<h4 id="1-1-3-2-Set"><a href="#1-1-3-2-Set" class="headerlink" title="1.1.3.2. Set"></a>1.1.3.2. Set</h4><ul>
<li><code>HashSet</code>（无序，唯一）: 基于 <code>HashMap</code> 实现的，底层采用 <code>HashMap</code> 来保存元素</li>
<li><code>LinkedHashSet</code>：<code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，并且其内部是通过 <code>LinkedHashMap</code> 来实现的。有点类似于我们之前说的 <code>LinkedHashMap</code> 其内部是基于 <code>HashMap</code> 实现一样，不过还是有一点点区别的</li>
<li><code>TreeSet</code>（有序，唯一）： 红黑树(自平衡的排序二叉树)</li>
</ul>
<p>再来看看 <code>Map</code> 接口下面的集合。</p>
<h4 id="1-1-3-3-Map"><a href="#1-1-3-3-Map" class="headerlink" title="1.1.3.3. Map"></a>1.1.3.3. Map</h4><ul>
<li><code>HashMap</code>： JDK1.8 之前 HashMap 由数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间</li>
<li><code>LinkedHashMap</code>： <code>LinkedHashMap</code> 继承自 <code>HashMap</code>，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，<code>LinkedHashMap</code> 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：<a href="https://www.imooc.com/article/22931" target="_blank" rel="noopener">《LinkedHashMap 源码详细分析（JDK1.8）》</a></li>
<li><code>Hashtable</code>： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li>
<li><code>TreeMap</code>： 红黑树（自平衡的排序二叉树）</li>
</ul>
<h3 id="1-1-4-如何选用集合"><a href="#1-1-4-如何选用集合" class="headerlink" title="1.1.4. 如何选用集合?"></a>1.1.4. 如何选用集合?</h3><p>主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用 <code>Map</code> 接口下的集合，需要排序时选择 <code>TreeMap</code>,不需要排序时就选择 <code>HashMap</code>,需要保证线程安全就选用 <code>ConcurrentHashMap</code>。</p>
<p>当我们只需要存放元素值时，就选择实现<code>Collection</code> 接口的集合，需要保证元素唯一时选择实现 <code>Set</code> 接口的集合比如 <code>TreeSet</code> 或 <code>HashSet</code>，不需要就选择实现 <code>List</code> 接口的比如 <code>ArrayList</code> 或 <code>LinkedList</code>，然后再根据实现这些接口的集合的特点来选用。</p>
<h3 id="1-1-5-为什么要使用集合？"><a href="#1-1-5-为什么要使用集合？" class="headerlink" title="1.1.5. 为什么要使用集合？"></a>1.1.5. 为什么要使用集合？</h3><p>当我们需要保存一组类型相同的数据的时候，我们应该是用一个容器来保存，这个容器就是数组，但是，使用数组存储对象具有一定的弊端，<br>因为我们在实际开发中，存储的数据的类型是多种多样的，于是，就出现了“集合”，集合同样也是用来存储多个数据的。</p>
<p>数组的缺点是一旦声明之后，长度就不可变了；同时，声明数组时的数据类型也决定了该数组存储的数据的类型；而且，数组存储的数据是有序的、可重复的，特点单一。<br>但是集合提高了数据存储的灵活性，Java 集合不仅可以用来存储不同类型不同数量的对象，还可以保存具有映射关系的数据</p>
<h3 id="1-1-6-Iterator-迭代器"><a href="#1-1-6-Iterator-迭代器" class="headerlink" title="1.1.6. Iterator 迭代器"></a>1.1.6. Iterator 迭代器</h3><h4 id="1-1-6-1-迭代器-Iterator-是什么？"><a href="#1-1-6-1-迭代器-Iterator-是什么？" class="headerlink" title="1.1.6.1. 迭代器 Iterator 是什么？"></a>1.1.6.1. 迭代器 Iterator 是什么？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <span class="hljs-comment">//集合中是否还有元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//获得集合中的下一个元素</span><br>    <span class="hljs-function">E <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>Iterator</code> 对象称为迭代器（设计模式的一种），迭代器可以对集合进行遍历，但每一个集合内部的数据结构可能是不尽相同的，所以每一个集合存和取都很可能是不一样的，虽然我们可以人为地在每一个类中定义 <code>hasNext()</code> 和 <code>next()</code> 方法，但这样做会让整个集合体系过于臃肿。于是就有了迭代器。</p>
<p>迭代器是将这样的方法抽取出接口，然后在每个类的内部，定义自己迭代方式，这样做就规定了整个集合体系的遍历方式都是 <code>hasNext()</code>和<code>next()</code>方法，使用者不用管怎么实现的，会用即可。迭代器的定义为：提供一种方法访问一个容器对象中各个元素，而又不需要暴露该对象的内部细节。</p>
<h4 id="1-1-6-2-迭代器-Iterator-有啥用？"><a href="#1-1-6-2-迭代器-Iterator-有啥用？" class="headerlink" title="1.1.6.2. 迭代器 Iterator 有啥用？"></a>1.1.6.2. 迭代器 Iterator 有啥用？</h4><p><code>Iterator</code> 主要是用来遍历集合用的，它的特点是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 <code>ConcurrentModificationException</code> 异常。</p>
<h4 id="1-1-6-3-如何使用？"><a href="#1-1-6-3-如何使用？" class="headerlink" title="1.1.6.3. 如何使用？"></a>1.1.6.3. 如何使用？</h4><p>我们通过使用迭代器来遍历 <code>HashMap</code>，演示一下 迭代器 Iterator 的使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>Map&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> HashMap();<br>map.put(<span class="hljs-number">1</span>, <span class="hljs-string">"Java"</span>);<br>map.put(<span class="hljs-number">2</span>, <span class="hljs-string">"C++"</span>);<br>map.put(<span class="hljs-number">3</span>, <span class="hljs-string">"PHP"</span>);<br>Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator = map.entrySet().iterator();<br><span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>  Map.Entry&lt;Integer, String&gt; entry = iterator.next();<br>  System.out.println(entry.getKey() + entry.getValue());<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="1-1-7-有哪些集合是线程不安全的？怎么解决呢？"><a href="#1-1-7-有哪些集合是线程不安全的？怎么解决呢？" class="headerlink" title="1.1.7. 有哪些集合是线程不安全的？怎么解决呢？"></a>1.1.7. 有哪些集合是线程不安全的？怎么解决呢？</h3><p>我们常用的 <code>Arraylist</code> ,<code>LinkedList</code>,<code>Hashmap</code>,<code>HashSet</code>,<code>TreeSet</code>,<code>TreeMap</code>，<code>PriorityQueue</code> 都不是线程安全的。解决办法很简单，可以使用线程安全的集合来代替。</p>
<p>如果你要使用线程安全的集合的话， <code>java.util.concurrent</code> 包中提供了很多并发容器供你使用：</p>
<ol>
<li><code>ConcurrentHashMap</code>: 可以看作是线程安全的 <code>HashMap</code></li>
<li><code>CopyOnWriteArrayList</code>:可以看作是线程安全的 <code>ArrayList</code>，在读多写少的场合性能非常好，远远好于 <code>Vector</code>.</li>
<li><code>ConcurrentLinkedQueue</code>:高效的并发队列，使用链表实现。可以看做一个线程安全的 <code>LinkedList</code>，这是一个非阻塞队列。</li>
<li><code>BlockingQueue</code>: 这是一个接口，JDK 内部通过链表、数组等方式实现了这个接口。表示阻塞队列，非常适合用于作为数据共享的通道。</li>
<li><code>ConcurrentSkipListMap</code> :跳表的实现。这是一个<code>Map</code>，使用跳表的数据结构进行快速查找。</li>
</ol>
<h2 id="1-2-Collection-子接口之-List"><a href="#1-2-Collection-子接口之-List" class="headerlink" title="1.2. Collection 子接口之 List"></a>1.2. Collection 子接口之 List</h2><h3 id="1-2-1-Arraylist-和-Vector-的区别"><a href="#1-2-1-Arraylist-和-Vector-的区别" class="headerlink" title="1.2.1. Arraylist 和 Vector 的区别?"></a>1.2.1. Arraylist 和 Vector 的区别?</h3><ol>
<li>ArrayList 是 List 的主要实现类，底层使用 Object[ ]存储，适用于频繁的查找工作，线程不安全 ；</li>
<li>Vector 是 List 的古老实现类，底层使用 Object[ ]存储，线程安全的。</li>
</ol>
<h3 id="1-2-2-Arraylist-与-LinkedList-区别"><a href="#1-2-2-Arraylist-与-LinkedList-区别" class="headerlink" title="1.2.2. Arraylist 与 LinkedList 区别?"></a>1.2.2. Arraylist 与 LinkedList 区别?</h3><ol>
<li><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</li>
<li><strong>底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li>
<li><strong>插入和删除是否受元素位置的影响：</strong> ① <strong><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② <strong><code>LinkedList</code> 采用链表存储，所以对于<code>add(E e)</code>方法的插入，删除元素时间复杂度不受元素位置的影响，近似 O(1)，如果是要在指定位置<code>i</code>插入和删除元素的话（<code>(add(int index, E element)</code>） 时间复杂度近似为<code>o(n))</code>因为需要先移动到指定位置再插入。</strong></li>
<li><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</li>
<li><strong>内存空间占用：</strong> ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li>
</ol>
<h4 id="1-2-2-1-补充内容-双向链表和双向循环链表"><a href="#1-2-2-1-补充内容-双向链表和双向循环链表" class="headerlink" title="1.2.2.1. 补充内容:双向链表和双向循环链表"></a>1.2.2.1. 补充内容:双向链表和双向循环链表</h4><p><strong>双向链表：</strong> 包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。</p>
<blockquote>
<p>另外推荐一篇把双向链表讲清楚的文章：<a href="https://juejin.im/post/5b5d1a9af265da0f47352f14" target="_blank" rel="noopener">https://juejin.im/post/5b5d1a9af265da0f47352f14</a></p>
</blockquote>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8.png" alt="双向链表"></p>
<p><strong>双向循环链表：</strong> 最后一个节点的 next 指向 head，而 head 的 prev 指向最后一个节点，构成一个环。</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E5%8F%8C%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8.png" alt="双向循环链表"></p>
<h4 id="1-2-2-2-补充内容-RandomAccess-接口"><a href="#1-2-2-2-补充内容-RandomAccess-接口" class="headerlink" title="1.2.2.2. 补充内容:RandomAccess 接口"></a>1.2.2.2. 补充内容:RandomAccess 接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RandomAccess</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>查看源码我们发现实际上 <code>RandomAccess</code> 接口中什么都没有定义。所以，在我看来 <code>RandomAccess</code> 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。</p>
<p>在 <code>binarySearch（)</code> 方法中，它要判断传入的 list 是否 <code>RamdomAccess</code> 的实例，如果是，调用<code>indexedBinarySearch()</code>方法，如果不是，那么调用<code>iteratorBinarySearch()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(List&lt;? extends Comparable&lt;? <span class="hljs-keyword">super</span> T&gt;&gt; list, T key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (list <span class="hljs-keyword">instanceof</span> RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)<br>        <span class="hljs-keyword">return</span> Collections.indexedBinarySearch(list, key);<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> Collections.iteratorBinarySearch(list, key);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口， 而 <code>LinkedList</code> 没有实现。为什么呢？我觉得还是和底层数据结构有关！<code>ArrayList</code> 底层是数组，而 <code>LinkedList</code> 底层是链表。数组天然支持随机访问，时间复杂度为 O(1)，所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O(n)，所以不支持快速随机访问。，<code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口，就表明了他具有快速随机访问功能。 <code>RandomAccess</code> 接口只是标识，并不是说 <code>ArrayList</code> 实现 <code>RandomAccess</code> 接口才具有快速随机访问功能的！</p>
<h3 id="1-2-3-说一说-ArrayList-的扩容机制吧"><a href="#1-2-3-说一说-ArrayList-的扩容机制吧" class="headerlink" title="1.2.3. 说一说 ArrayList 的扩容机制吧"></a>1.2.3. 说一说 ArrayList 的扩容机制吧</h3><p>详见笔主的这篇文章:<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/collection/ArrayList-Grow.md" target="_blank" rel="noopener">通过源码一步一步分析 ArrayList 扩容机制</a></p>
<h2 id="1-3-Collection-子接口之-Set"><a href="#1-3-Collection-子接口之-Set" class="headerlink" title="1.3. Collection 子接口之 Set"></a>1.3. Collection 子接口之 Set</h2><h3 id="1-3-1-comparable-和-Comparator-的区别"><a href="#1-3-1-comparable-和-Comparator-的区别" class="headerlink" title="1.3.1. comparable 和 Comparator 的区别"></a>1.3.1. comparable 和 Comparator 的区别</h3><ul>
<li><code>comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</li>
<li><code>comparator</code>接口实际上是出自 java.util 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</li>
</ul>
<p>一般我们需要对一个集合使用自定义排序时，我们就要重写<code>compareTo()</code>方法或<code>compare()</code>方法，当我们需要对某一个集合实现两种排序方式，比如一个 song 对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写<code>compareTo()</code>方法和使用自制的<code>Comparator</code>方法或者以两个 Comparator 来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 <code>Collections.sort()</code>.</p>
<h4 id="1-3-1-1-Comparator-定制排序"><a href="#1-3-1-1-Comparator-定制排序" class="headerlink" title="1.3.1.1. Comparator 定制排序"></a>1.3.1.1. Comparator 定制排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Integer&gt; arrayList = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>arrayList.add(-<span class="hljs-number">1</span>);<br>arrayList.add(<span class="hljs-number">3</span>);<br>arrayList.add(<span class="hljs-number">3</span>);<br>arrayList.add(-<span class="hljs-number">5</span>);<br>arrayList.add(<span class="hljs-number">7</span>);<br>arrayList.add(<span class="hljs-number">4</span>);<br>arrayList.add(-<span class="hljs-number">9</span>);<br>arrayList.add(-<span class="hljs-number">7</span>);<br>System.out.println(<span class="hljs-string">"原始数组:"</span>);<br>System.out.println(arrayList);<br><span class="hljs-comment">// void reverse(List list)：反转</span><br>Collections.reverse(arrayList);<br>System.out.println(<span class="hljs-string">"Collections.reverse(arrayList):"</span>);<br>System.out.println(arrayList);<br><br><span class="hljs-comment">// void sort(List list),按自然排序的升序排序</span><br>Collections.sort(arrayList);<br>System.out.println(<span class="hljs-string">"Collections.sort(arrayList):"</span>);<br>System.out.println(arrayList);<br><span class="hljs-comment">// 定制排序的用法</span><br>Collections.sort(arrayList, <span class="hljs-keyword">new</span> Comparator&lt;Integer&gt;() &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> o2.compareTo(o1);<br>    &#125;<br>&#125;);<br>System.out.println(<span class="hljs-string">"定制排序后："</span>);<br>System.out.println(arrayList);<br></code></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">原始数组:<br>[<span class="hljs-number">-1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">-5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">-9</span>, <span class="hljs-number">-7</span>]<br>Collections.reverse(<span class="hljs-built_in">array</span>List):<br>[<span class="hljs-number">-7</span>, <span class="hljs-number">-9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">-5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">-1</span>]<br>Collections.sort(<span class="hljs-built_in">array</span>List):<br>[<span class="hljs-number">-9</span>, <span class="hljs-number">-7</span>, <span class="hljs-number">-5</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>]<br>定制排序后：<br>[<span class="hljs-number">7</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-5</span>, <span class="hljs-number">-7</span>, <span class="hljs-number">-9</span>]<br></code></pre></td></tr></table></figure>

<h4 id="1-3-1-2-重写-compareTo-方法实现按年龄来排序"><a href="#1-3-1-2-重写-compareTo-方法实现按年龄来排序" class="headerlink" title="1.3.1.2. 重写 compareTo 方法实现按年龄来排序"></a>1.3.1.2. 重写 compareTo 方法实现按年龄来排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列</span><br><span class="hljs-comment">// 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他</span><br><span class="hljs-comment">// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了</span><br><span class="hljs-keyword">public</span>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Person</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>();<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * T重写compareTo方法实现按年龄来排序</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Person o)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.age &gt; o.getAge()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.age &lt; o.getAge()) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    TreeMap&lt;Person, String&gt; pdata = <span class="hljs-keyword">new</span> TreeMap&lt;Person, String&gt;();<br>    pdata.put(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">"张三"</span>, <span class="hljs-number">30</span>), <span class="hljs-string">"zhangsan"</span>);<br>    pdata.put(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">"李四"</span>, <span class="hljs-number">20</span>), <span class="hljs-string">"lisi"</span>);<br>    pdata.put(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">"王五"</span>, <span class="hljs-number">10</span>), <span class="hljs-string">"wangwu"</span>);<br>    pdata.put(<span class="hljs-keyword">new</span> Person(<span class="hljs-string">"小红"</span>, <span class="hljs-number">5</span>), <span class="hljs-string">"xiaohong"</span>);<br>    <span class="hljs-comment">// 得到key的值的同时得到key所对应的值</span><br>    Set&lt;Person&gt; keys = pdata.keySet();<br>    <span class="hljs-keyword">for</span> (Person key : keys) &#123;<br>        System.out.println(key.getAge() + <span class="hljs-string">"-"</span> + key.getName());<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Output：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">5</span>-小红<br><span class="hljs-number">10</span>-王五<br><span class="hljs-number">20</span>-李四<br><span class="hljs-number">30</span>-张三<br></code></pre></td></tr></table></figure>

<h3 id="1-3-2-无序性和不可重复性的含义是什么"><a href="#1-3-2-无序性和不可重复性的含义是什么" class="headerlink" title="1.3.2. 无序性和不可重复性的含义是什么"></a>1.3.2. 无序性和不可重复性的含义是什么</h3><p>1、什么是无序性？无序性不等于随机性 ，无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。</p>
<p>2、什么是不可重复性？不可重复性是指添加的元素按照 equals()判断时 ，返回 false，需要同时重写 equals()方法和 HashCode()方法。</p>
<h3 id="1-3-3-比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#1-3-3-比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="1.3.3. 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>1.3.3. 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h3><p>HashSet 是 Set 接口的主要实现类 ，HashSet 的底层是 HashMap，线程不安全的，可以存储 null 值；</p>
<p>LinkedHashSet 是 HashSet 的子类，能够按照添加的顺序遍历；</p>
<p>TreeSet 底层使用红黑树，能够按照添加元素的顺序进行遍历，排序的方式有自然排序和定制排序。</p>
<h2 id="1-4-Map-接口"><a href="#1-4-Map-接口" class="headerlink" title="1.4. Map 接口"></a>1.4. Map 接口</h2><h3 id="1-4-1-HashMap-和-Hashtable-的区别"><a href="#1-4-1-HashMap-和-Hashtable-的区别" class="headerlink" title="1.4.1. HashMap 和 Hashtable 的区别"></a>1.4.1. HashMap 和 Hashtable 的区别</h3><ol>
<li><strong>线程是否安全：</strong> HashMap 是非线程安全的，HashTable 是线程安全的,因为 HashTable 内部的方法基本都经过<code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap 吧！）；</li>
<li><strong>效率：</strong> 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</li>
<li><strong>对 Null key 和 Null value 的支持：</strong> HashMap 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；HashTable 不允许有 null 键和 null 值，否则会抛出 NullPointerException。</li>
<li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ① 创建时如果不指定容量初始值，Hashtable 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。HashMap 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。② 创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为 2 的幂次方大小（HashMap 中的<code>tableSizeFor()</code>方法保证，下面给出了源代码）。也就是说 HashMap 总是使用 2 的幂作为哈希表的大小,后面会介绍到为什么是 2 的幂次方。</li>
<li><strong>底层数据结构：</strong> JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li>
</ol>
<p><strong>HashMap 中带有初始容量的构造函数：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Illegal initial capacity: "</span> +<br>                                           initialCapacity);<br>    <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>        initialCapacity = MAXIMUM_CAPACITY;<br>    <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Illegal load factor: "</span> +<br>                                           loadFactor);<br>    <span class="hljs-keyword">this</span>.loadFactor = loadFactor;<br>    <span class="hljs-keyword">this</span>.threshold = tableSizeFor(initialCapacity);<br>&#125;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>下面这个方法保证了 HashMap 总是使用 2 的幂作为哈希表的大小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns a power of two size for the given target capacity.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tableSizeFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cap)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = cap - <span class="hljs-number">1</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">2</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">4</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">8</span>;<br>    n |= n &gt;&gt;&gt; <span class="hljs-number">16</span>;<br>    <span class="hljs-keyword">return</span> (n &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="1-4-2-HashMap-和-HashSet-区别"><a href="#1-4-2-HashMap-和-HashSet-区别" class="headerlink" title="1.4.2. HashMap 和 HashSet 区别"></a>1.4.2. HashMap 和 HashSet 区别</h3><p>如果你看过 <code>HashSet</code> 源码的话就应该知道：HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了 <code>clone()</code>、<code>writeObject()</code>、<code>readObject()</code>是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。</p>
<table>
<thead>
<tr>
<th align="center">HashMap</th>
<th align="center">HashSet</th>
</tr>
</thead>
<tbody><tr>
<td align="center">实现了 Map 接口</td>
<td align="center">实现 Set 接口</td>
</tr>
<tr>
<td align="center">存储键值对</td>
<td align="center">仅存储对象</td>
</tr>
<tr>
<td align="center">调用 <code>put()</code>向 map 中添加元素</td>
<td align="center">调用 <code>add()</code>方法向 Set 中添加元素</td>
</tr>
<tr>
<td align="center">HashMap 使用键（Key）计算 Hashcode</td>
<td align="center">HashSet 使用成员对象来计算 hashcode 值，对于两个对象来说 hashcode 可能相同，所以 equals()方法用来判断对象的相等性，</td>
</tr>
</tbody></table>
<h3 id="1-4-3-HashMap-和-TreeMap-区别"><a href="#1-4-3-HashMap-和-TreeMap-区别" class="headerlink" title="1.4.3. HashMap 和 TreeMap 区别"></a>1.4.3. HashMap 和 TreeMap 区别</h3><p><code>TreeMap</code> 和<code>HashMap</code> 都继承自<code>AbstractMap</code> ，但是需要注意的是<code>TreeMap</code>它还实现了<code>NavigableMap</code>接口和<code>SortedMap</code> 接口。</p>
<p><img src="images/TreeMap%E7%BB%A7%E6%89%BF%E7%BB%93%E6%9E%84.png" alt></p>
<p>实现 <code>NavigableMap</code> 接口让 <code>TreeMap</code> 有了对集合内元素的搜索的能力。</p>
<p>实现<code>SortMap</code>接口让 <code>TreeMap</code> 有了对集合中的元素根据键排序的能力。默认是按 key 的升序排序，不过我们也可以指定排序的比较器。示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> shuang.kou</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@createTime</span> 2020年06月15日 17:02:00</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer age;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(Integer age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        TreeMap&lt;Person, String&gt; treeMap = <span class="hljs-keyword">new</span> TreeMap&lt;&gt;(<span class="hljs-keyword">new</span> Comparator&lt;Person&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Person person1, Person person2)</span> </span>&#123;<br>                <span class="hljs-keyword">int</span> num = person1.getAge() - person2.getAge();<br>                <span class="hljs-keyword">return</span> Integer.compare(num, <span class="hljs-number">0</span>);<br>            &#125;<br>        &#125;);<br>        treeMap.put(<span class="hljs-keyword">new</span> Person(<span class="hljs-number">3</span>), <span class="hljs-string">"person1"</span>);<br>        treeMap.put(<span class="hljs-keyword">new</span> Person(<span class="hljs-number">18</span>), <span class="hljs-string">"person2"</span>);<br>        treeMap.put(<span class="hljs-keyword">new</span> Person(<span class="hljs-number">35</span>), <span class="hljs-string">"person3"</span>);<br>        treeMap.put(<span class="hljs-keyword">new</span> Person(<span class="hljs-number">16</span>), <span class="hljs-string">"person4"</span>);<br>        treeMap.entrySet().stream().forEach(personStringEntry -&gt; &#123;<br>            System.out.println(personStringEntry.getValue());<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode">perso<span class="hljs-symbol">n1</span><br>perso<span class="hljs-symbol">n4</span><br>perso<span class="hljs-symbol">n2</span><br>perso<span class="hljs-symbol">n3</span><br></code></pre></td></tr></table></figure>

<p>可以看出，<code>TreeMap</code> 中的元素已经是按照 <code>Person</code> 的 age 字段的升序来排列了。</p>
<p>上面，我们是通过传入匿名内部类的方式实现的，你可以将代码替换成 Lambda 表达式实现的方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">TreeMap&lt;Person, String&gt; treeMap = <span class="hljs-keyword">new</span> TreeMap&lt;&gt;((person1, person2) -&gt; &#123;<br>  <span class="hljs-keyword">int</span> num = person1.getAge() - person2.getAge();<br>  <span class="hljs-keyword">return</span> Integer.compare(num, <span class="hljs-number">0</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>

<p><strong>综上，相比于<code>HashMap</code>来说 <code>TreeMap</code> 主要多了对集合中的元素根据键排序的能力以及对集合内元素的搜索的能力。</strong></p>
<h3 id="1-4-4-HashSet-如何检查重复"><a href="#1-4-4-HashSet-如何检查重复" class="headerlink" title="1.4.4. HashSet 如何检查重复"></a>1.4.4. HashSet 如何检查重复</h3><p>当你把对象加入<code>HashSet</code>时，HashSet 会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用<code>equals()</code>方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让加入操作成功。（摘自我的 Java 启蒙书《Head fist java》第二版）</p>
<p><strong>hashCode()与 equals()的相关规定：</strong></p>
<ol>
<li>如果两个对象相等，则 hashcode 一定也是相同的</li>
<li>两个对象相等,对两个 equals 方法返回 true</li>
<li>两个对象有相同的 hashcode 值，它们也不一定是相等的</li>
<li>综上，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</li>
<li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li>
</ol>
<p><strong>==与 equals 的区别</strong></p>
<p>对于基本类型来说，== 比较的是值是否相等；</p>
<p>对于引用类型来说，== 比较的是两个引用是否指向同一个对象地址（两者在内存中存放的地址（堆内存地址）是否指向同一个地方）；</p>
<p>对于引用类型（包括包装类型）来说，equals 如果没有被重写，对比它们的地址是否相等；如果 equals()方法被重写（例如 String），则比较的是地址里的内容。</p>
<h3 id="1-4-5-HashMap-的底层实现"><a href="#1-4-5-HashMap-的底层实现" class="headerlink" title="1.4.5. HashMap 的底层实现"></a>1.4.5. HashMap 的底层实现</h3><h4 id="1-4-5-1-JDK1-8-之前"><a href="#1-4-5-1-JDK1-8-之前" class="headerlink" title="1.4.5.1. JDK1.8 之前"></a>1.4.5.1. JDK1.8 之前</h4><p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。<strong>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</strong></p>
<p><strong>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</strong></p>
<p><strong>JDK 1.8 HashMap 的 hash 方法源码:</strong></p>
<p>JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> h;<br>    <span class="hljs-comment">// key.hashCode()：返回散列值也就是hashcode</span><br>    <span class="hljs-comment">// ^ ：按位异或</span><br>    <span class="hljs-comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span><br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对比一下 JDK1.7 的 HashMap 的 hash 方法源码.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h)</span> </span>&#123;<br>    <span class="hljs-comment">// This function ensures that hashCodes that differ only by</span><br>    <span class="hljs-comment">// constant multiples at each bit position have a bounded</span><br>    <span class="hljs-comment">// number of collisions (approximately 8 at default load factor).</span><br><br>    h ^= (h &gt;&gt;&gt; <span class="hljs-number">20</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">12</span>);<br>    <span class="hljs-keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="hljs-number">7</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">4</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p>
<p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>
<p><img src="images/jdk1.8%E4%B9%8B%E5%89%8D%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84-HashMap.png" alt="jdk1.8之前的内部结构-HashMap"></p>
<h4 id="1-4-5-2-JDK1-8-之后"><a href="#1-4-5-2-JDK1-8-之后" class="headerlink" title="1.4.5.2. JDK1.8 之后"></a>1.4.5.2. JDK1.8 之后</h4><p>相比于之前的版本， JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p>
<p><img src="images/jdk1.8%E4%B9%8B%E5%90%8E%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84-HashMap.png" alt="jdk1.8之后的内部结构-HashMap"></p>
<blockquote>
<p>TreeMap、TreeSet 以及 JDK1.8 之后的 HashMap 底层都用到了红黑树。红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p>
</blockquote>
<h3 id="1-4-6-HashMap-的长度为什么是-2-的幂次方"><a href="#1-4-6-HashMap-的长度为什么是-2-的幂次方" class="headerlink" title="1.4.6. HashMap 的长度为什么是 2 的幂次方"></a>1.4.6. HashMap 的长度为什么是 2 的幂次方</h3><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648 到 2147483647，前后加起来大概 40 亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ <code>(n - 1) &amp; hash</code>”。（n 代表数组长度）。这也就解释了 HashMap 的长度为什么是 2 的幂次方。</p>
<p><strong>这个算法应该如何设计呢？</strong></p>
<p>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：<strong>“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是 2 的 n 次方；）。”</strong> 并且 <strong>采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。</strong></p>
<h3 id="1-4-7-HashMap-多线程操作导致死循环问题"><a href="#1-4-7-HashMap-多线程操作导致死循环问题" class="headerlink" title="1.4.7. HashMap 多线程操作导致死循环问题"></a>1.4.7. HashMap 多线程操作导致死循环问题</h3><p>主要原因在于并发下的 Rehash 会造成元素之间会形成一个循环链表。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap,因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap 。</p>
<p>详情请查看：<a href="https://coolshell.cn/articles/9606.html" target="_blank" rel="noopener">https://coolshell.cn/articles/9606.html</a></p>
<h3 id="1-4-8-HashMap-有哪几种常见的遍历方式"><a href="#1-4-8-HashMap-有哪几种常见的遍历方式" class="headerlink" title="1.4.8. HashMap 有哪几种常见的遍历方式?"></a>1.4.8. HashMap 有哪几种常见的遍历方式?</h3><p><a href="https://mp.weixin.qq.com/s/Zz6mofCtmYpABDL1ap04ow" target="_blank" rel="noopener">HashMap 的 7 种遍历方式与性能分析！</a></p>
<h3 id="1-4-9-ConcurrentHashMap-和-Hashtable-的区别"><a href="#1-4-9-ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="1.4.9. ConcurrentHashMap 和 Hashtable 的区别"></a>1.4.9. ConcurrentHashMap 和 Hashtable 的区别</h3><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p>
<ul>
<li><strong>底层数据结构：</strong> JDK1.7 的 ConcurrentHashMap 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟 HashMap1.8 的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li>
<li><strong>实现线程安全的方式（重要）：</strong> ① <strong>在 JDK1.7 的时候，ConcurrentHashMap（分段锁）</strong> 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 <strong>到了 JDK1.8 的时候已经摒弃了 Segment 的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6 以后 对 synchronized 锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 HashMap，虽然在 JDK1.8 中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② <strong>Hashtable(同一把锁)</strong> :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>
</ul>
<p><strong>两者的对比图：</strong></p>
<p><strong>HashTable:</strong></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/HashTable%E5%85%A8%E8%A1%A8%E9%94%81.png" alt="HashTable全表锁"></p>
<p style="text-align:right;font-size:13px;color:gray">http://www.cnblogs.com/chengxiao/p/6842045.html></p>

<p><strong>JDK1.7 的 ConcurrentHashMap：</strong></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/ConcurrentHashMap%E5%88%86%E6%AE%B5%E9%94%81.jpg" alt="JDK1.7的ConcurrentHashMap"></p>
<p style="text-align:right;font-size:13px;color:gray">http://www.cnblogs.com/chengxiao/p/6842045.html></p>

<p><strong>JDK1.8 的 ConcurrentHashMap：</strong></p>
<p><img src="./images/java8_concurrenthashmap.png" alt="Java8 ConcurrentHashMap 存储结构（图片来自 javadoop）"></p>
<p>JDK1.8 的 <code>ConcurrentHashMap</code> 不在是 <strong>Segment 数组 + HashEntry 数组 + 链表</strong>，而是 <strong>Node 数组 + 链表 / 红黑树</strong>。不过，Node 只能用于链表的情况，红黑树的情况需要使用 <strong><code>TreeNode</code></strong>。当冲突链表达到一定长度时，链表会转换成红黑树。</p>
<h3 id="1-4-10-ConcurrentHashMap-线程安全的具体实现方式-底层具体实现"><a href="#1-4-10-ConcurrentHashMap-线程安全的具体实现方式-底层具体实现" class="headerlink" title="1.4.10. ConcurrentHashMap 线程安全的具体实现方式/底层具体实现"></a>1.4.10. ConcurrentHashMap 线程安全的具体实现方式/底层具体实现</h3><h4 id="1-4-10-1-JDK1-7（上面有示意图）"><a href="#1-4-10-1-JDK1-7（上面有示意图）" class="headerlink" title="1.4.10.1. JDK1.7（上面有示意图）"></a>1.4.10.1. JDK1.7（上面有示意图）</h4><p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>
<p><strong>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成</strong>。</p>
<p>Segment 实现了 ReentrantLock,所以 Segment 是一种可重入锁，扮演锁的角色。HashEntry 用于存储键值对数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Segment</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ReentrantLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和 HashMap 类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个 HashEntry 数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 的锁。</p>
<h4 id="1-4-10-2-JDK1-8-（上面有示意图）"><a href="#1-4-10-2-JDK1-8-（上面有示意图）" class="headerlink" title="1.4.10.2. JDK1.8 （上面有示意图）"></a>1.4.10.2. JDK1.8 （上面有示意图）</h4><p>ConcurrentHashMap 取消了 Segment 分段锁，采用 CAS 和 synchronized 来保证并发安全。数据结构跟 HashMap1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）</p>
<p>synchronized 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。</p>
<h2 id="1-5-Collections-工具类"><a href="#1-5-Collections-工具类" class="headerlink" title="1.5. Collections 工具类"></a>1.5. Collections 工具类</h2><p>Collections 工具类常用方法:</p>
<ol>
<li>排序</li>
<li>查找,替换操作</li>
<li>同步控制(不推荐，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合)</li>
</ol>
<h3 id="1-5-1-排序操作"><a href="#1-5-1-排序操作" class="headerlink" title="1.5.1. 排序操作"></a>1.5.1. 排序操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reverse</span><span class="hljs-params">(List list)</span><span class="hljs-comment">//反转</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shuffle</span><span class="hljs-params">(List list)</span><span class="hljs-comment">//随机排序</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(List list)</span><span class="hljs-comment">//按自然排序的升序排序</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(List list, Comparator c)</span><span class="hljs-comment">//定制排序，由Comparator控制排序逻辑</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(List list, <span class="hljs-keyword">int</span> i , <span class="hljs-keyword">int</span> j)</span><span class="hljs-comment">//交换两个索引位置的元素</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(List list, <span class="hljs-keyword">int</span> distance)</span><span class="hljs-comment">//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面</span></span><br></code></pre></td></tr></table></figure>

<h3 id="1-5-2-查找-替换操作"><a href="#1-5-2-查找-替换操作" class="headerlink" title="1.5.2. 查找,替换操作"></a>1.5.2. 查找,替换操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(List list, Object key)</span><span class="hljs-comment">//对List进行二分查找，返回索引，注意List必须是有序的</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(Collection coll)</span><span class="hljs-comment">//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">(Collection coll, Comparator c)</span><span class="hljs-comment">//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fill</span><span class="hljs-params">(List list, Object obj)</span><span class="hljs-comment">//用指定的元素代替指定list中的所有元素。</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">frequency</span><span class="hljs-params">(Collection c, Object o)</span><span class="hljs-comment">//统计元素出现次数</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">indexOfSubList</span><span class="hljs-params">(List list, List target)</span><span class="hljs-comment">//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target).</span></span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">replaceAll</span><span class="hljs-params">(List list, Object oldVal, Object newVal)</span>, 用新元素替换旧元素</span><br></code></pre></td></tr></table></figure>

<h3 id="1-5-3-同步控制"><a href="#1-5-3-同步控制" class="headerlink" title="1.5.3. 同步控制"></a>1.5.3. 同步控制</h3><p><code>Collections</code> 提供了多个<code>synchronizedXxx()</code>方法·，该方法可以将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。</p>
<p>我们知道 <code>HashSet</code>，<code>TreeSet</code>，<code>ArrayList</code>,<code>LinkedList</code>,<code>HashMap</code>,<code>TreeMap</code> 都是线程不安全的。<code>Collections</code> 提供了多个静态方法可以把他们包装成线程同步的集合。</p>
<p><strong>最好不要用下面这些方法，效率非常低，需要线程安全的集合类型时请考虑使用 JUC 包下的并发集合。</strong></p>
<p>方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">synchronizedCollection(Collection&lt;T&gt;  c) <span class="hljs-comment">//返回指定 collection 支持的同步（线程安全的）collection。</span><br>synchronizedList(List&lt;T&gt; list)<span class="hljs-comment">//返回指定列表支持的同步（线程安全的）List。</span><br>synchronizedMap(Map&lt;K,V&gt; m) <span class="hljs-comment">//返回由指定映射支持的同步（线程安全的）Map。</span><br>synchronizedSet(Set&lt;T&gt; s) <span class="hljs-comment">//返回指定 set 支持的同步（线程安全的）set。</span><br></code></pre></td></tr></table></figure>

<h2 id="1-6-其他重要问题"><a href="#1-6-其他重要问题" class="headerlink" title="1.6. 其他重要问题"></a>1.6. 其他重要问题</h2><h3 id="1-6-1-什么是快速失败-fail-fast-？"><a href="#1-6-1-什么是快速失败-fail-fast-？" class="headerlink" title="1.6.1. 什么是快速失败(fail-fast)？"></a>1.6.1. 什么是快速失败(fail-fast)？</h3><p><strong>快速失败(fail-fast)</strong> 是 Java 集合的一种错误检测机制。<strong>在使用迭代器对集合进行遍历的时候，我们在多线程下操作非安全失败(fail-safe)的集合类可能就会触发 fail-fast 机制，导致抛出 <code>ConcurrentModificationException</code> 异常。 另外，在单线程下，如果在遍历过程中对集合对象的内容进行了修改的话也会触发 fail-fast 机制。</strong></p>
<blockquote>
<p>注：增强 for 循环也是借助迭代器进行遍历。</p>
</blockquote>
<p>举个例子：多线程下，如果线程 1 正在对集合进行遍历，此时线程 2 对集合进行修改（增加、删除、修改），或者线程 1 在遍历过程中对集合进行修改，都会导致线程 1 抛出 <code>ConcurrentModificationException</code> 异常。</p>
<p><strong>为什么呢？</strong></p>
<p>每当迭代器使用 <code>hashNext()</code>/<code>next()</code>遍历下一个元素之前，都会检测 <code>modCount</code> 变量是否为 <code>expectedModCount</code> 值，是的话就返回遍历；否则抛出异常，终止遍历。</p>
<p>如果我们在集合被遍历期间对其进行修改的话，就会改变 <code>modCount</code> 的值，进而导致 <code>modCount != expectedModCount</code> ，进而抛出 <code>ConcurrentModificationException</code> 异常。</p>
<blockquote>
<p>注：通过 <code>Iterator</code> 的方法修改集合的话会修改到 <code>expectedModCount</code> 的值，所以不会抛出异常。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkForComodification</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>好吧！相信大家已经搞懂了快速失败(fail-fast)机制以及它的原理。</p>
<p>我们再来趁热打铁，看一个阿里巴巴手册相关的规定：</p>
<p><img src="images/ad28e3ba-e419-4724-869c-73879e604da1.png" alt></p>
<p>有了前面讲的基础，我们应该知道：使用 <code>Iterator</code> 提供的 <code>remove</code> 方法，可以修改到 <code>expectedModCount</code> 的值。所以，才不会再抛出<code>ConcurrentModificationException</code> 异常。</p>
<h3 id="1-6-2-什么是安全失败-fail-safe-呢？"><a href="#1-6-2-什么是安全失败-fail-safe-呢？" class="headerlink" title="1.6.2. 什么是安全失败(fail-safe)呢？"></a>1.6.2. 什么是安全失败(fail-safe)呢？</h3><p>明白了快速失败(fail-fast)之后，安全失败(fail-safe)我们就很好理解了。</p>
<p>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。所以，在遍历过程中对原集合所作的修改并不能被迭代器检测到，故不会抛 <code>ConcurrentModificationException</code> 异常。</p>
<h3 id="1-6-3-Arrays-asList-避坑指南"><a href="#1-6-3-Arrays-asList-避坑指南" class="headerlink" title="1.6.3. Arrays.asList()避坑指南"></a>1.6.3. Arrays.asList()避坑指南</h3><p>最近使用<code>Arrays.asList()</code>遇到了一些坑，然后在网上看到这篇文章：<a href="http://javadevnotes.com/java-array-to-list-examples" target="_blank" rel="noopener">Java Array to List Examples</a> 感觉挺不错的，但是还不是特别全面。所以，自己对于这块小知识点进行了简单的总结。</p>
<h4 id="1-6-3-1-简介"><a href="#1-6-3-1-简介" class="headerlink" title="1.6.3.1. 简介"></a>1.6.3.1. 简介</h4><p><code>Arrays.asList()</code>在平时开发中还是比较常见的，我们可以使用它将一个数组转换为一个 List 集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] myArray = &#123; <span class="hljs-string">"Apple"</span>, <span class="hljs-string">"Banana"</span>, <span class="hljs-string">"Orange"</span> &#125;；<br>List&lt;String&gt; myList = Arrays.asList(myArray);<br><span class="hljs-comment">//上面两个语句等价于下面一条语句</span><br>List&lt;String&gt; myList = Arrays.asList(<span class="hljs-string">"Apple"</span>,<span class="hljs-string">"Banana"</span>, <span class="hljs-string">"Orange"</span>);<br></code></pre></td></tr></table></figure>

<p>JDK 源码对于这个方法的说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *返回由指定数组支持的固定大小的列表。此方法作为基于数组和基于集合的API之间的桥梁，与           Collection.toArray()结合使用。返回的List是可序列化并实现RandomAccess接口。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">asList</span><span class="hljs-params">(T... a)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(a);<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="1-6-3-2-《阿里巴巴-Java-开发手册》对其的描述"><a href="#1-6-3-2-《阿里巴巴-Java-开发手册》对其的描述" class="headerlink" title="1.6.3.2. 《阿里巴巴 Java 开发手册》对其的描述"></a>1.6.3.2. 《阿里巴巴 Java 开发手册》对其的描述</h4><p><code>Arrays.asList()</code>将数组转换为集合后,底层其实还是数组，《阿里巴巴 Java 开发手册》对于这个方法有如下描述：</p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-6/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B-Arrays.asList()%E6%96%B9%E6%B3%95.png" alt="阿里巴巴Java开发手-Arrays.asList()方法"></p>
<h4 id="1-6-3-3-使用时的注意事项总结"><a href="#1-6-3-3-使用时的注意事项总结" class="headerlink" title="1.6.3.3. 使用时的注意事项总结"></a>1.6.3.3. 使用时的注意事项总结</h4><p><strong>传递的数组必须是对象数组，而不是基本类型。</strong></p>
<p><code>Arrays.asList()</code>是泛型方法，传入的对象必须是对象数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] myArray = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br>List myList = Arrays.asList(myArray);<br>System.out.println(myList.size());<span class="hljs-comment">//1</span><br>System.out.println(myList.get(<span class="hljs-number">0</span>));<span class="hljs-comment">//数组地址值</span><br>System.out.println(myList.get(<span class="hljs-number">1</span>));<span class="hljs-comment">//报错：ArrayIndexOutOfBoundsException</span><br><span class="hljs-keyword">int</span> [] array=(<span class="hljs-keyword">int</span>[]) myList.get(<span class="hljs-number">0</span>);<br>System.out.println(array[<span class="hljs-number">0</span>]);<span class="hljs-comment">//1</span><br></code></pre></td></tr></table></figure>

<p>当传入一个原生数据类型数组时，<code>Arrays.asList()</code> 的真正得到的参数就不是数组中的元素，而是数组对象本身！此时 List 的唯一元素就是这个数组，这也就解释了上面的代码。</p>
<p>我们使用包装类型数组就可以解决这个问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer[] myArray = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br></code></pre></td></tr></table></figure>

<p><strong>使用集合的修改方法:<code>add()</code>、<code>remove()</code>、<code>clear()</code>会抛出异常。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List myList = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>myList.add(<span class="hljs-number">4</span>);<span class="hljs-comment">//运行时报错：UnsupportedOperationException</span><br>myList.remove(<span class="hljs-number">1</span>);<span class="hljs-comment">//运行时报错：UnsupportedOperationException</span><br>myList.clear();<span class="hljs-comment">//运行时报错：UnsupportedOperationException</span><br></code></pre></td></tr></table></figure>

<p><code>Arrays.asList()</code> 方法返回的并不是 <code>java.util.ArrayList</code> ，而是 <code>java.util.Arrays</code> 的一个内部类,这个内部类并没有实现集合的修改方法或者说并没有重写这些方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List myList = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>System.out.println(myList.getClass());<span class="hljs-comment">//class java.util.Arrays$ArrayList</span><br></code></pre></td></tr></table></figure>

<p>下图是<code>java.util.Arrays$ArrayList</code>的简易源码，我们可以看到这个类重写的方法有哪些。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractList</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">      <span class="hljs-keyword">implements</span> <span class="hljs-title">RandomAccess</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span><br><span class="hljs-class">  </span>&#123;<br>      ...<br><br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        ...<br>      &#125;<br><br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E element)</span> </span>&#123;<br>        ...<br>      &#125;<br><br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        ...<br>      &#125;<br><br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>         ...<br>      &#125;<br><br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-keyword">super</span> E&gt; action)</span> </span>&#123;<br>        ...<br>      &#125;<br><br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">replaceAll</span><span class="hljs-params">(UnaryOperator&lt;E&gt; operator)</span> </span>&#123;<br>        ...<br>      &#125;<br><br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-keyword">super</span> E&gt; c)</span> </span>&#123;<br>        ...<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>我们再看一下<code>java.util.AbstractList</code>的<code>remove()</code>方法，这样我们就明白为啥会抛出<code>UnsupportedOperationException</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<p><strong>转载自：</strong><br><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98?id=111-java-%e9%9b%86%e5%90%88%e6%a6%82%e8%a7%88" target="_blank" rel="noopener">https://snailclimb.gitee.io/javaguide/#/docs/java/collection/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98?id=111-java-%e9%9b%86%e5%90%88%e6%a6%82%e8%a7%88</a></p>

    </div>
    
    
    
        <div class="reward-container">
  <div>假装有人支持！</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.jpg" alt="YunTang1997 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="YunTang1997 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>YunTang1997
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://yuntang1997.github.io/2020/08/20/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/" title="剖析面试最常见问题之Java集合框架">https://yuntang1997.github.io/2020/08/20/Java集合框架常见面试题/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

      

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/08/20/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/" rel="prev" title="Java抽象类的构造函数">
      <i class="fa fa-chevron-left"></i> Java抽象类的构造函数
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC81MDU0Mi8yNzAyNQ=="></div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-剖析面试最常见问题之-Java-集合框架"><span class="nav-number">1.</span> <span class="nav-text">1. 剖析面试最常见问题之 Java 集合框架</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-集合概述"><span class="nav-number">1.1.</span> <span class="nav-text">1.1. 集合概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-1-Java-集合概览"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1.1. Java 集合概览</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-2-说说-List-Set-Map-三者的区别？"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.1.2. 说说 List,Set,Map 三者的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-3-集合框架底层数据结构总结"><span class="nav-number">1.1.3.</span> <span class="nav-text">1.1.3. 集合框架底层数据结构总结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-3-1-List"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">1.1.3.1. List</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-3-2-Set"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">1.1.3.2. Set</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-3-3-Map"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">1.1.3.3. Map</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-4-如何选用集合"><span class="nav-number">1.1.4.</span> <span class="nav-text">1.1.4. 如何选用集合?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-5-为什么要使用集合？"><span class="nav-number">1.1.5.</span> <span class="nav-text">1.1.5. 为什么要使用集合？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-6-Iterator-迭代器"><span class="nav-number">1.1.6.</span> <span class="nav-text">1.1.6. Iterator 迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-6-1-迭代器-Iterator-是什么？"><span class="nav-number">1.1.6.1.</span> <span class="nav-text">1.1.6.1. 迭代器 Iterator 是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-6-2-迭代器-Iterator-有啥用？"><span class="nav-number">1.1.6.2.</span> <span class="nav-text">1.1.6.2. 迭代器 Iterator 有啥用？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-6-3-如何使用？"><span class="nav-number">1.1.6.3.</span> <span class="nav-text">1.1.6.3. 如何使用？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-7-有哪些集合是线程不安全的？怎么解决呢？"><span class="nav-number">1.1.7.</span> <span class="nav-text">1.1.7. 有哪些集合是线程不安全的？怎么解决呢？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-Collection-子接口之-List"><span class="nav-number">1.2.</span> <span class="nav-text">1.2. Collection 子接口之 List</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1-Arraylist-和-Vector-的区别"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.2.1. Arraylist 和 Vector 的区别?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-2-Arraylist-与-LinkedList-区别"><span class="nav-number">1.2.2.</span> <span class="nav-text">1.2.2. Arraylist 与 LinkedList 区别?</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-1-补充内容-双向链表和双向循环链表"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">1.2.2.1. 补充内容:双向链表和双向循环链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2-2-补充内容-RandomAccess-接口"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">1.2.2.2. 补充内容:RandomAccess 接口</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-3-说一说-ArrayList-的扩容机制吧"><span class="nav-number">1.2.3.</span> <span class="nav-text">1.2.3. 说一说 ArrayList 的扩容机制吧</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-Collection-子接口之-Set"><span class="nav-number">1.3.</span> <span class="nav-text">1.3. Collection 子接口之 Set</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-1-comparable-和-Comparator-的区别"><span class="nav-number">1.3.1.</span> <span class="nav-text">1.3.1. comparable 和 Comparator 的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-1-1-Comparator-定制排序"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">1.3.1.1. Comparator 定制排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-1-2-重写-compareTo-方法实现按年龄来排序"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">1.3.1.2. 重写 compareTo 方法实现按年龄来排序</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-2-无序性和不可重复性的含义是什么"><span class="nav-number">1.3.2.</span> <span class="nav-text">1.3.2. 无序性和不可重复性的含义是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-3-比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><span class="nav-number">1.3.3.</span> <span class="nav-text">1.3.3. 比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-Map-接口"><span class="nav-number">1.4.</span> <span class="nav-text">1.4. Map 接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-1-HashMap-和-Hashtable-的区别"><span class="nav-number">1.4.1.</span> <span class="nav-text">1.4.1. HashMap 和 Hashtable 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-2-HashMap-和-HashSet-区别"><span class="nav-number">1.4.2.</span> <span class="nav-text">1.4.2. HashMap 和 HashSet 区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-3-HashMap-和-TreeMap-区别"><span class="nav-number">1.4.3.</span> <span class="nav-text">1.4.3. HashMap 和 TreeMap 区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-4-HashSet-如何检查重复"><span class="nav-number">1.4.4.</span> <span class="nav-text">1.4.4. HashSet 如何检查重复</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-5-HashMap-的底层实现"><span class="nav-number">1.4.5.</span> <span class="nav-text">1.4.5. HashMap 的底层实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-5-1-JDK1-8-之前"><span class="nav-number">1.4.5.1.</span> <span class="nav-text">1.4.5.1. JDK1.8 之前</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-5-2-JDK1-8-之后"><span class="nav-number">1.4.5.2.</span> <span class="nav-text">1.4.5.2. JDK1.8 之后</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-6-HashMap-的长度为什么是-2-的幂次方"><span class="nav-number">1.4.6.</span> <span class="nav-text">1.4.6. HashMap 的长度为什么是 2 的幂次方</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-7-HashMap-多线程操作导致死循环问题"><span class="nav-number">1.4.7.</span> <span class="nav-text">1.4.7. HashMap 多线程操作导致死循环问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-8-HashMap-有哪几种常见的遍历方式"><span class="nav-number">1.4.8.</span> <span class="nav-text">1.4.8. HashMap 有哪几种常见的遍历方式?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-9-ConcurrentHashMap-和-Hashtable-的区别"><span class="nav-number">1.4.9.</span> <span class="nav-text">1.4.9. ConcurrentHashMap 和 Hashtable 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-10-ConcurrentHashMap-线程安全的具体实现方式-底层具体实现"><span class="nav-number">1.4.10.</span> <span class="nav-text">1.4.10. ConcurrentHashMap 线程安全的具体实现方式&#x2F;底层具体实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-10-1-JDK1-7（上面有示意图）"><span class="nav-number">1.4.10.1.</span> <span class="nav-text">1.4.10.1. JDK1.7（上面有示意图）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-10-2-JDK1-8-（上面有示意图）"><span class="nav-number">1.4.10.2.</span> <span class="nav-text">1.4.10.2. JDK1.8 （上面有示意图）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-Collections-工具类"><span class="nav-number">1.5.</span> <span class="nav-text">1.5. Collections 工具类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-1-排序操作"><span class="nav-number">1.5.1.</span> <span class="nav-text">1.5.1. 排序操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-2-查找-替换操作"><span class="nav-number">1.5.2.</span> <span class="nav-text">1.5.2. 查找,替换操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-3-同步控制"><span class="nav-number">1.5.3.</span> <span class="nav-text">1.5.3. 同步控制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-6-其他重要问题"><span class="nav-number">1.6.</span> <span class="nav-text">1.6. 其他重要问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-1-什么是快速失败-fail-fast-？"><span class="nav-number">1.6.1.</span> <span class="nav-text">1.6.1. 什么是快速失败(fail-fast)？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-2-什么是安全失败-fail-safe-呢？"><span class="nav-number">1.6.2.</span> <span class="nav-text">1.6.2. 什么是安全失败(fail-safe)呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-3-Arrays-asList-避坑指南"><span class="nav-number">1.6.3.</span> <span class="nav-text">1.6.3. Arrays.asList()避坑指南</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-3-1-简介"><span class="nav-number">1.6.3.1.</span> <span class="nav-text">1.6.3.1. 简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-3-2-《阿里巴巴-Java-开发手册》对其的描述"><span class="nav-number">1.6.3.2.</span> <span class="nav-text">1.6.3.2. 《阿里巴巴 Java 开发手册》对其的描述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-3-3-使用时的注意事项总结"><span class="nav-number">1.6.3.3.</span> <span class="nav-text">1.6.3.3. 使用时的注意事项总结</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="YunTang1997"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">YunTang1997</p>
  <div class="site-description" itemprop="description">不要因为一时的安逸蒙蔽了双眼，出来混迟早要还的</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">50</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/YunTang1997" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;YunTang1997" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.csdn.net/" title="CSDN → https:&#x2F;&#x2F;www.csdn.net&#x2F;" rel="noopener" target="_blank"><i class="fab fa-superpowers fa-fw"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:2074402078@qq.com" title="E-Mail → mailto:2074402078@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="ttps://www.google.com.hk/webhp?hl=zh-CN&sourceid=cnhp" title="Google → ttps:&#x2F;&#x2F;www.google.com.hk&#x2F;webhp?hl&#x3D;zh-CN&amp;sourceid&#x3D;cnhp" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i>Google</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      推荐阅读
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://www.liaoxuefeng.com/wiki/1016959663602400" title="https:&#x2F;&#x2F;www.liaoxuefeng.com&#x2F;wiki&#x2F;1016959663602400" rel="noopener" target="_blank">廖雪峰python教程</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.bilibili.com/video/BV1cW411r7c5" title="https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1cW411r7c5" rel="noopener" target="_blank">尚硅谷Hadoop教程(hadoop框架精讲)</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.bilibili.com/video/BV12b411K7Zu" title="https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV12b411K7Zu" rel="noopener" target="_blank">MySQL基础+高级篇</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://book.douban.com/subject/26702568/" title="https:&#x2F;&#x2F;book.douban.com&#x2F;subject&#x2F;26702568&#x2F;" rel="noopener" target="_blank">《数据结构与算法 python语言描述》</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://book.douban.com/subject/23008813/" title="https:&#x2F;&#x2F;book.douban.com&#x2F;subject&#x2F;23008813&#x2F;" rel="noopener" target="_blank">《高性能MySQL》</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2018 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YunTang1997</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">161k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">2:27</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>





        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        我的第<span id="busuanzi_value_site_uv"></span>位朋友
      </span>
    </span>
    <span class="post-meta-divider">|</span>
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        在第<span id="busuanzi_value_site_pv"></span>次后相遇
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




  

  

<script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"left","width":100,"height":200},"mobile":{"show":true},"log":false});</script></body>
</html>
